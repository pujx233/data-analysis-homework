# 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

# 四平方定理。
# 四平方定理讲的就是任何一个正整数都可以表示成不超过四个整数的平方之和。也就是说，这道题的答案只有 1，2 ，3，4 这四种可能。
# 同时，还有一个非常重要的推论满足四数平方和定理的数n（这里要满足由四个数构成，小于四个不行），必定满足 n = 4a * (8b + 7)。
# 根据这个重要的推论来解决此题，首先将输入的n迅速缩小。
# 然后再判断，这个缩小后的数是否可以通过两个平方数的和或一个平方数组成，不能的话我们返回3，能的话我们返回平方数的个数。

# 另一种思路：对问题建模：将整个问题变成一个图论问题。
# 从n到0，每个数字代表一个节点;；
# 如果两个数 x 到 y 相差一个完全平方数，则连接一条边；
# 我们就得到了一个无权图；
# 原来的问题就转化为，在这个无权图中找出从 n 到 0 的最短路径，所以需要 BFS 来完成
# 有人可能会通过贪心算法来处理该问题，但这是错误的，因为我们要找的是最少个数，贪心可能找的是最简单的树，而数量可能会很多。


def sum_of_squares(num):
    while num % 4 == 0:
        num //= 4
    if num % 8 == 7:
        return 4
    a = 0
    while a * a <= num:
        b = int(pow((num - a * a), 0.5))
        if a * a + b * b == num:
            if a != 0 and b != 0:
                return 2
            else:
                return 1
        a += 1
    return 3


print(sum_of_squares(int(input())))